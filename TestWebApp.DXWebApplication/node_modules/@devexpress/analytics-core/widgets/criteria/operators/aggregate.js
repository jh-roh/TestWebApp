/**
* DevExpress Analytics (widgets\criteria\operators\aggregate.js)
* Version:  22.1.5
* Build date: Sep 5, 2022
* Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
* License: https://www.devexpress.com/Support/EULAs/universal.xml
*/
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.AggregateOperand = void 0;
var criteriaOperator_1 = require("./criteriaOperator");
var unary_1 = require("./unary");
var binary_1 = require("./options/binary");
var unary_2 = require("./options/unary");
var group_1 = require("./options/group");
var criteriaOperatorPreprocessor_1 = require("../utils/criteriaOperatorPreprocessor");
var AggregateOperand = (function (_super) {
    __extends(AggregateOperand, _super);
    function AggregateOperand(property, aggregatedExpression, aggregateType, condition) {
        var _this = _super.call(this) || this;
        _this.change = function (operationType, item) {
            var operator = null;
            if (operationType.type === group_1.GroupOperatorType) {
                operator = criteriaOperatorPreprocessor_1.criteriaCreator.changeByType(operationType);
                if (operationType.type !== operator.enumType) {
                    operator.leftPart.assignFrom(item);
                }
                else {
                    operator.assignFrom(item);
                }
                _this.condition = operator;
            }
            return operator;
        };
        _this.assignLeftPart = function (criteriaOperator) {
            if (criteriaOperator.leftPart instanceof AggregateOperand) {
                _this.assignFrom(criteriaOperator.leftPart);
            }
            else {
                if (criteriaOperator instanceof AggregateOperand) {
                    _this.property = criteriaOperator.property;
                    if (_this.aggregatedExpression && criteriaOperator.aggregatedExpression) {
                        _this.aggregatedExpression = criteriaOperator.aggregatedExpression;
                    }
                    _this.condition = criteriaOperator.condition;
                }
                else {
                    _this.property = criteriaOperator.leftPart;
                }
            }
        };
        _this.type = 'aggregate';
        _this.property = property;
        if (!!condition && condition.type === 'group') {
            _this.condition = condition;
        }
        else {
            if (condition instanceof unary_1.UnaryOperator && condition.operatorType === unary_2.UnaryOperatorType.Not) {
                if (condition.operand.type === 'group') {
                    _this.condition = criteriaOperatorPreprocessor_1.criteriaCreator.process('unary', { operator: condition.operand, operatorType: unary_2.UnaryOperatorType.Not });
                }
                else {
                    _this.condition = criteriaOperatorPreprocessor_1.criteriaCreator.process('unary', {
                        operator: criteriaOperatorPreprocessor_1.criteriaCreator.process('group', {
                            operation: group_1.GroupOperatorType.And,
                            operands: condition.operand ? [condition.operand] : []
                        }),
                        operatorType: unary_2.UnaryOperatorType.Not
                    });
                }
            }
            else {
                _this.condition = criteriaOperatorPreprocessor_1.criteriaCreator.process('group', {
                    operation: group_1.GroupOperatorType.And,
                    operands: condition ? [condition] : []
                });
            }
        }
        _this.operatorType = aggregateType;
        _this.aggregatedExpression = aggregatedExpression;
        return _this;
    }
    Object.defineProperty(AggregateOperand.prototype, "displayType", {
        get: function () {
            return this.operatorType;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(AggregateOperand.prototype, "enumType", {
        get: function () {
            return AggregateOperand;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(AggregateOperand.prototype, "leftPart", {
        get: function () {
            return this.property;
        },
        enumerable: false,
        configurable: true
    });
    AggregateOperand.prototype.children = function () {
        var operands = [];
        this.condition && operands.push(this.condition);
        this.aggregatedExpression && operands.push(this.aggregatedExpression);
        return operands;
    };
    AggregateOperand.prototype.accept = function (visitor) {
        return visitor.visitAggregateOperand
            ? visitor.visitAggregateOperand(this)
            : criteriaOperatorPreprocessor_1.criteriaCreator.process('aggregate', {
                aggregateType: this.operatorType,
                aggregatedExpression: this.aggregatedExpression && this.aggregatedExpression.accept(visitor),
                condition: this.condition && this.condition.accept(visitor),
                property: this.property && this.property.accept(visitor)
            });
    };
    return AggregateOperand;
}(criteriaOperator_1.CriteriaOperator));
exports.AggregateOperand = AggregateOperand;
criteriaOperatorPreprocessor_1.criteriaCreator.register('aggregate', function (options) {
    return new AggregateOperand(options.property, options.aggregatedExpression, options.aggregateType, options.condition);
}, function (operatorType) {
    var options = {
        property: criteriaOperatorPreprocessor_1.criteriaCreator.process('property'),
        aggregateType: operatorType.value,
        aggregatedExpression: null,
        condition: criteriaOperatorPreprocessor_1.criteriaCreator.process('group', { operation: group_1.GroupOperatorType.And, operands: [] })
    };
    if (operatorType.value === 'Exists') {
        return criteriaOperatorPreprocessor_1.criteriaCreator.process('aggregate', options);
    }
    else {
        if (operatorType.value !== 'Count') {
            options.aggregatedExpression = criteriaOperatorPreprocessor_1.criteriaCreator.process('property');
        }
        return criteriaOperatorPreprocessor_1.criteriaCreator.process('binary', {
            left: criteriaOperatorPreprocessor_1.criteriaCreator.process('aggregate', options),
            right: criteriaOperatorPreprocessor_1.criteriaCreator.process('value', { value: undefined }),
            operatorType: binary_1.BinaryOperatorType.Equal
        });
    }
});
