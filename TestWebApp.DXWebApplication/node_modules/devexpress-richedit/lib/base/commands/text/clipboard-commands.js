"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BuiltInClipboardAction = exports.InsertHtmlCommand = exports.ClipboardHelper = exports.BuiltInClipboard = exports.PasteSelectionCommand = exports.CutSelectionCommand = exports.CopySelectionCommand = exports.ClipboardCommand = void 0;
var tslib_1 = require("tslib");
var options_1 = require("../../../core/formats/options");
var model_manager_1 = require("../../../core/model-manager");
var create_range_copy_operation_1 = require("../../../core/model/manipulators/range/create-range-copy-operation");
var control_1 = require("../../../core/model/options/control");
var sub_document_1 = require("../../../core/model/sub-document");
var browser_1 = require("@devexpress/utils/lib/browser");
var batch_updatable_1 = require("@devexpress/utils/lib/class/batch-updatable");
var errors_1 = require("@devexpress/utils/lib/errors");
var dom_1 = require("@devexpress/utils/lib/utils/dom");
var list_1 = require("@devexpress/utils/lib/utils/list");
var html_importer_1 = require("../../../html/import/html-importer");
var txt_exporter_1 = require("../../../txt/txt-exporter");
var txt_importer_1 = require("../../../txt/txt-importer");
var selection_history_item_1 = require("../../model/history/selection/selection-history-item");
var client_command_1 = require("../client-command");
var command_base_1 = require("../command-base");
var command_states_1 = require("../command-states");
var ClipboardCommand = (function (_super) {
    tslib_1.__extends(ClipboardCommand, _super);
    function ClipboardCommand(control, queryCommandId) {
        var _this = _super.call(this, control) || this;
        _this.queryCommandId = queryCommandId;
        if (_this.isTouchMode())
            ClipboardCommand.builtInClipboard = new BuiltInClipboard(_this.control);
        _this.clipboardHelper = new ClipboardHelper(_this.control, _this.isTouchMode());
        return _this;
    }
    ClipboardCommand.prototype.getState = function () {
        var state = new command_states_1.SimpleCommandState(this.isEnabled());
        state.visible = this.isVisible();
        return state;
    };
    ClipboardCommand.prototype.isTouchMode = function () {
        return this.control.isTouchMode();
    };
    ClipboardCommand.prototype.isCommandSupported = function () {
        var editableDocument = this.control.inputController.getEditableDocument();
        return !!editableDocument.queryCommandSupported && editableDocument.queryCommandSupported(this.queryCommandId);
    };
    ClipboardCommand.prototype.execute = function (isPublicApiCall, parameter) {
        var _this = this;
        if (parameter === void 0) { parameter = this.control.shortcutManager.lastCommandExecutedByShortcut; }
        var isPublicApiCallPrevValue = this.control.commandManager.isPublicApiCall;
        this.control.commandManager.isPublicApiCall = isPublicApiCall;
        if (!this.isTouchMode() && !parameter && !this.isCommandSupported()) {
            this.control.commandManager.isPublicApiCall = isPublicApiCallPrevValue;
            if (this.clipboardHelper.canReadFromClipboard()) {
                this.clipboardHelper.readFromClipboard().then(function () { }, function () { return _this.executeShowErrorMessageCommand(); });
                return true;
            }
            else
                return this.executeShowErrorMessageCommand();
        }
        else {
            var options = this.convertToCommandOptions(parameter);
            this.beforeExecute();
            this.executeCore(this.getState(), options);
            this.control.commandManager.isPublicApiCall = isPublicApiCallPrevValue;
            return true;
        }
    };
    ClipboardCommand.prototype.executeCore = function (state, options) {
        var _this = this;
        if (!state.enabled || this.control.commandManager.clipboardTimerId != null)
            return false;
        if (!this.isTouchMode()) {
            if (!options.param)
                this.control.inputController.getEditableDocument().execCommand(this.queryCommandId, false, null);
            this.control.commandManager.clipboardTimerId = setTimeout(function () {
                _this.executeFinalAction();
            }, this.getTimeout());
        }
        else
            this.executeBuiltInClipboardAction(this.getBuiltInClipboardActionType());
        return true;
    };
    ClipboardCommand.prototype.getTimeout = function () {
        return ClipboardCommand.timeout;
    };
    ClipboardCommand.prototype.executeFinalAction = function () {
        if (this.control.isClosed() || this.control.commandManager.clipboardTimerId === null)
            return;
        this.control.beginUpdate();
        this.changeModel();
        var editableDocument = this.control.inputController.getEditableDocument();
        if (browser_1.Browser.TouchUI) {
            getSelection().removeAllRanges();
            dom_1.DomUtils.clearInnerHtml(browser_1.Browser.MSTouchUI ? editableDocument.body : editableDocument);
        }
        else {
            var selection = editableDocument.getSelection ?
                editableDocument.getSelection() :
                editableDocument.selection;
            if (selection.removeAllRanges)
                selection.removeAllRanges();
            else if (selection.empty)
                selection.empty();
            dom_1.DomUtils.clearInnerHtml(editableDocument.body);
        }
        if (!browser_1.Browser.TouchUI || browser_1.Browser.IE && browser_1.Browser.MSTouchUI)
            this.control.inputController.selectEditableDocumentContent();
        else
            getSelection().selectAllChildren(editableDocument);
        this.control.endUpdate();
        this.control.commandManager.clipboardTimerId = null;
    };
    ClipboardCommand.prototype.executeShowErrorMessageCommand = function () {
        return this.control.commandManager.getCommand(client_command_1.RichEditClientCommand.ShowErrorClipboardAccessDeniedMessageCommand).execute(this.control.commandManager.isPublicApiCall);
    };
    ClipboardCommand.prototype.executeBuiltInClipboardAction = function (action) {
        this.control.beginUpdate();
        switch (action) {
            case BuiltInClipboardAction.Copy:
                ClipboardCommand.builtInClipboard.copy();
                this.tryWriteToClipboard();
                break;
            case BuiltInClipboardAction.Cut:
                ClipboardCommand.builtInClipboard.cut();
                this.tryWriteToClipboard();
                break;
            case BuiltInClipboardAction.Paste:
                if (this.clipboardHelper.canReadFromClipboard()) {
                    this.clipboardHelper.readFromClipboard().catch(function (reason) {
                        ClipboardCommand.builtInClipboard.paste();
                        console.log(reason);
                    });
                }
                else
                    ClipboardCommand.builtInClipboard.paste();
                break;
        }
        this.control.endUpdate();
    };
    ClipboardCommand.prototype.tryWriteToClipboard = function () {
        this.clipboardHelper.tryWriteToClipboard(ClipboardCommand.builtInClipboard.clipboardData).catch(function (reason) { return console.log(reason); });
    };
    ClipboardCommand.prototype.isVisible = function () {
        return true;
    };
    ClipboardCommand.prototype.getBuiltInClipboardActionType = function () {
        throw new Error(errors_1.Errors.NotImplemented);
    };
    ClipboardCommand.prototype.changeModel = function () {
    };
    ClipboardCommand.prototype.beforeExecute = function () {
        if (!browser_1.Browser.TouchUI)
            this.control.focusManager.captureFocus();
    };
    ClipboardCommand.additionalWaitingTimeForMac = 10;
    ClipboardCommand.timeout = browser_1.Browser.Firefox ? 10 :
        (browser_1.Browser.MacOSPlatform && (browser_1.Browser.WebKitFamily || browser_1.Browser.Opera) ? 10 : 0);
    return ClipboardCommand;
}(command_base_1.CommandBase));
exports.ClipboardCommand = ClipboardCommand;
var CopySelectionCommand = (function (_super) {
    tslib_1.__extends(CopySelectionCommand, _super);
    function CopySelectionCommand(control) {
        return _super.call(this, control, "copy") || this;
    }
    CopySelectionCommand.prototype.copyEventRaised = function () {
        var _this = this;
        if (browser_1.Browser.MacOSPlatform && this.control.commandManager.clipboardTimerId !== null) {
            setTimeout(function () {
                clearTimeout(_this.control.commandManager.clipboardTimerId);
                _this.executeFinalAction();
            }, ClipboardCommand.additionalWaitingTimeForMac);
        }
    };
    CopySelectionCommand.prototype.getTimeout = function () {
        return browser_1.Browser.MacOSPlatform ? 300 : _super.prototype.getTimeout.call(this);
    };
    CopySelectionCommand.prototype.isEnabled = function () {
        return _super.prototype.isEnabled.call(this) && control_1.ControlOptions.isEnabled(this.control.modelManager.richOptions.control.copy) && !this.selection.isCollapsed();
    };
    CopySelectionCommand.prototype.isVisible = function () {
        return control_1.ControlOptions.isVisible(this.control.modelManager.richOptions.control.copy);
    };
    CopySelectionCommand.prototype.getBuiltInClipboardActionType = function () {
        return BuiltInClipboardAction.Copy;
    };
    CopySelectionCommand.prototype.beforeExecute = function () {
        if (control_1.ControlOptions.isEnabled(this.control.modelManager.richOptions.control.copy)) {
            _super.prototype.beforeExecute.call(this);
            if (!this.isTouchMode())
                this.control.inputController.renderSelectionToEditableDocument();
        }
    };
    CopySelectionCommand.prototype.isEnabledInReadOnlyMode = function () {
        return true;
    };
    return CopySelectionCommand;
}(ClipboardCommand));
exports.CopySelectionCommand = CopySelectionCommand;
var CutSelectionCommand = (function (_super) {
    tslib_1.__extends(CutSelectionCommand, _super);
    function CutSelectionCommand(control) {
        return _super.call(this, control, "cut") || this;
    }
    CutSelectionCommand.prototype.changeModel = function () {
        var _this = this;
        this.history.addTransaction(function () {
            var intervals = list_1.ListUtils.deepCopy(_this.selection.intervalsInfo.intervals);
            list_1.ListUtils.reverseForEach(intervals, function (interval) {
                return _this.modelManipulator.range.removeInterval(new sub_document_1.SubDocumentInterval(_this.selection.activeSubDocument, interval), true, true);
            });
            _this.history.addAndRedo(new selection_history_item_1.SelectionHistoryItem(_this.modelManipulator, _this.selection, _this.selection.getState(), _this.selection.getState().setPosition(intervals[0].start)));
        });
    };
    CutSelectionCommand.prototype.isEnabled = function () {
        return _super.prototype.isEnabled.call(this) && control_1.ControlOptions.isEnabled(this.control.modelManager.richOptions.control.cut) && !this.selection.isCollapsed();
    };
    CutSelectionCommand.prototype.isVisible = function () {
        return control_1.ControlOptions.isVisible(this.control.modelManager.richOptions.control.cut);
    };
    CutSelectionCommand.prototype.getBuiltInClipboardActionType = function () {
        return BuiltInClipboardAction.Cut;
    };
    CutSelectionCommand.prototype.beforeExecute = function () {
        if (control_1.ControlOptions.isEnabled(this.control.modelManager.richOptions.control.cut)) {
            _super.prototype.beforeExecute.call(this);
            if (!this.isTouchMode())
                this.control.inputController.renderSelectionToEditableDocument();
        }
    };
    return CutSelectionCommand;
}(ClipboardCommand));
exports.CutSelectionCommand = CutSelectionCommand;
var PasteSelectionCommand = (function (_super) {
    tslib_1.__extends(PasteSelectionCommand, _super);
    function PasteSelectionCommand(control) {
        return _super.call(this, control, "paste") || this;
    }
    PasteSelectionCommand.prototype.getTimeout = function () {
        return browser_1.Browser.MacOSPlatform ? 300 : _super.prototype.getTimeout.call(this);
    };
    PasteSelectionCommand.prototype.pasteEventRaised = function () {
        var _this = this;
        if (browser_1.Browser.MacOSPlatform && this.control.commandManager.clipboardTimerId !== null) {
            setTimeout(function () {
                clearTimeout(_this.control.commandManager.clipboardTimerId);
                _this.executeFinalAction();
            }, ClipboardCommand.additionalWaitingTimeForMac);
        }
    };
    PasteSelectionCommand.prototype.changeModel = function () {
        this.control.inputController.setEditableDocumentContent(html_importer_1.HtmlImporter.convertHtml(this.control.inputController.getEditableDocumentContent()));
        var editableElement = this.control.inputController.getEditableDocument();
        var elementsContainer = editableElement.body || editableElement;
        var elements = elementsContainer.childNodes;
        if (!this.control.isLoadingPictureFromClipboard)
            this.control.importHtml(elements);
    };
    PasteSelectionCommand.prototype.isEnabled = function () {
        return _super.prototype.isEnabled.call(this) && control_1.ControlOptions.isEnabled(this.control.modelManager.richOptions.control.paste);
    };
    PasteSelectionCommand.prototype.isVisible = function () {
        return control_1.ControlOptions.isVisible(this.control.modelManager.richOptions.control.paste) || this.isTouchMode();
    };
    PasteSelectionCommand.prototype.getBuiltInClipboardActionType = function () {
        return BuiltInClipboardAction.Paste;
    };
    PasteSelectionCommand.prototype.beforeExecute = function () {
        if (control_1.ControlOptions.isEnabled(this.control.modelManager.richOptions.control.paste)) {
            _super.prototype.beforeExecute.call(this);
            if (!this.isTouchMode()) {
                var selection = browser_1.Browser.TouchUI ? window.getSelection() : this.control.inputController.getEditableDocument().getSelection();
                selection.removeAllRanges();
                var editableElement = this.control.inputController.getEditableDocument();
                selection.selectAllChildren(editableElement.body || editableElement);
            }
        }
    };
    PasteSelectionCommand.prototype.isCommandSupported = function () {
        return browser_1.Browser.IE;
    };
    return PasteSelectionCommand;
}(ClipboardCommand));
exports.PasteSelectionCommand = PasteSelectionCommand;
var BuiltInClipboard = (function () {
    function BuiltInClipboard(control) {
        this.control = control;
    }
    Object.defineProperty(BuiltInClipboard.prototype, "clipboardData", {
        get: function () { return this._clipboardData; },
        enumerable: false,
        configurable: true
    });
    BuiltInClipboard.prototype.copy = function () {
        this._clipboardData = create_range_copy_operation_1.RangeCopy.create(this.control.selection.subDocumentIntervals);
    };
    BuiltInClipboard.prototype.paste = function () {
        if (this._clipboardData) {
            this.control.modelManager.modelManipulator.range.removeInterval(this.control.selection.subDocumentInterval, true, false);
            this._clipboardData.insertTo(this.control.modelManager.modelManipulator, this.control.selection.intervalsInfo.subDocPosition);
        }
    };
    BuiltInClipboard.prototype.cut = function () {
        var _this = this;
        this.control.modelManager.history.addTransaction(function () {
            _this.copy();
            list_1.ListUtils.reverseForEach(_this.control.selection.intervalsInfo.intervals, function (interval) {
                return _this.control.modelManager.modelManipulator.range.removeInterval(new sub_document_1.SubDocumentInterval(_this.control.selection.activeSubDocument, interval), true, true);
            });
            _this.control.modelManager.history.addAndRedo(new selection_history_item_1.SelectionHistoryItem(_this.control.modelManager.modelManipulator, _this.control.selection, _this.control.selection.getState(), _this.control.selection.getState()
                .setPosition(_this.control.selection.intervalsInfo.intervals[0].start)));
        });
    };
    return BuiltInClipboard;
}());
exports.BuiltInClipboard = BuiltInClipboard;
var ClipboardHelper = (function () {
    function ClipboardHelper(control, useWithBuildInClipboard) {
        if (useWithBuildInClipboard === void 0) { useWithBuildInClipboard = false; }
        this.control = control;
        this.useWithBuildInClipboard = useWithBuildInClipboard;
    }
    Object.defineProperty(ClipboardHelper.prototype, "clipboard", {
        get: function () {
            return navigator.clipboard;
        },
        enumerable: false,
        configurable: true
    });
    ClipboardHelper.prototype.canReadFromClipboard = function () {
        return !!(this.clipboard && (this.clipboard.read || this.clipboard.readText));
    };
    ClipboardHelper.prototype.readFromClipboard = function () {
        var _this = this;
        if (this.clipboard.read)
            return this.clipboard.read().then(function (items) { return _this.tryInsertClipboardItems(items); });
        else if (this.clipboard.readText)
            return this.clipboard.readText().then(function (text) { return _this.insertPlainText(text); });
    };
    ClipboardHelper.prototype.tryReadFromClipboard = function () {
        if (this.canReadFromClipboard())
            return this.readFromClipboard();
        return new Promise(function (_resolve, reject) { return reject(ClipboardHelper.ContextIsNotSecureMessage); });
    };
    ClipboardHelper.prototype.tryInsertClipboardItems = function (items) {
        var _this = this;
        for (var _i = 0, items_1 = items; _i < items_1.length; _i++) {
            var item = items_1[_i];
            if (list_1.ListUtils.anyOf(item.types, function (type) { return type == ClipboardHelper.MIME_type_html; }))
                return this.insertClipboardItem(item, ClipboardHelper.MIME_type_html, function (html) { return _this.insertHtml(html); });
            if (list_1.ListUtils.anyOf(item.types, function (type) { return type == ClipboardHelper.MIME_type_plain; }))
                return this.insertClipboardItem(item, ClipboardHelper.MIME_type_plain, function (text) { return _this.insertPlainText(text); });
        }
        return new Promise(function (_resolve, reject) { return reject('There is no any supported data in the clipboard.'); });
    };
    ClipboardHelper.prototype.insertClipboardItem = function (item, contentType, insert) {
        var _this = this;
        return item.getType(contentType)
            .then(function (blob) { return _this.readAsText(blob); })
            .then(function (text) { return insert(text); });
    };
    ClipboardHelper.prototype.insertPlainText = function (text) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            if (ClipboardHelper.lastWritenTextHash === _this.calculateHash(text))
                reject();
            ClipboardHelper.lastWritenTextHash = -1;
            var command = new InsertPlainTextCommand(_this.control);
            if (command.execute(false, new command_base_1.CommandSimpleOptions(_this.control, text)))
                resolve();
            else
                reject('The clipboard item cannot be inserted.');
        });
    };
    ClipboardHelper.prototype.insertHtml = function (html) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var command = _this.control.commandManager.getCommand(client_command_1.RichEditClientCommand.InsertHtml);
            if (command.execute(false, html))
                resolve();
            else
                reject('The clipboard item cannot be inserted.');
        });
    };
    ClipboardHelper.prototype.canWriteToClipboard = function () {
        var _a;
        return !!((_a = this.clipboard) === null || _a === void 0 ? void 0 : _a.writeText);
    };
    ClipboardHelper.prototype.writeToClipboard = function (clipboardData) {
        var _this = this;
        ClipboardHelper.lastWritenTextHash = -1;
        return new Promise(function (resolve, reject) {
            var exporter = new txt_exporter_1.TxtExporter(_this.createModelManager(clipboardData.model).modelManipulator, new options_1.DocumentExporterOptions());
            exporter.exportToBlob(function (blob) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
                var text;
                return tslib_1.__generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4, this.readAsText(blob)];
                        case 1:
                            text = _a.sent();
                            if (this.useWithBuildInClipboard)
                                ClipboardHelper.lastWritenTextHash = this.calculateHash(text);
                            this.clipboard.writeText(text)
                                .then(function () { return resolve(); })
                                .catch(function (reason) { return reject(reason); });
                            return [2];
                    }
                });
            }); });
        });
    };
    ClipboardHelper.prototype.tryWriteToClipboard = function (clipboardData) {
        if (this.canWriteToClipboard())
            return this.writeToClipboard(clipboardData);
        return new Promise(function (_resolve, reject) { return reject(ClipboardHelper.ContextIsNotSecureMessage); });
    };
    ClipboardHelper.prototype.calculateHash = function (text) {
        var hash = 0;
        if (text.length === 0)
            return hash;
        for (var i = 0; i < text.length; i++) {
            hash = ((hash << 5) - hash) + text.charCodeAt(i);
            hash |= 0;
        }
        return hash;
    };
    ClipboardHelper.prototype.readAsText = function (blob) {
        return blob.text();
    };
    ClipboardHelper.prototype.createModelManager = function (model) {
        return new model_manager_1.ClientModelManager(model, this.control.modelManager.richOptions, new batch_updatable_1.EmptyBatchUpdatableObject());
    };
    ClipboardHelper.MIME_type_plain = 'text/plain';
    ClipboardHelper.MIME_type_html = 'text/html';
    ClipboardHelper.ContextIsNotSecureMessage = 'The context is not secure.';
    ClipboardHelper.lastWritenTextHash = -1;
    return ClipboardHelper;
}());
exports.ClipboardHelper = ClipboardHelper;
var InsertHtmlCommand = (function (_super) {
    tslib_1.__extends(InsertHtmlCommand, _super);
    function InsertHtmlCommand() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    InsertHtmlCommand.prototype.getState = function () {
        return new command_states_1.SimpleCommandState(this.isEnabled());
    };
    InsertHtmlCommand.prototype.executeCore = function (_state, options) {
        var _this = this;
        this.control.inputController.setEditableDocumentContent(html_importer_1.HtmlImporter.convertHtml(options.param));
        var editableElement = this.control.inputController.getEditableDocument();
        var elementsContainer = editableElement.body || editableElement;
        var elements = elementsContainer.childNodes;
        this.history.addTransaction(function () {
            var charPropsBundle = _this.inputPosition.charPropsBundle;
            _this.modelManipulator.range.removeInterval(_this.selection.subDocumentInterval, true, false);
            new html_importer_1.HtmlImporter(_this.control.modelManager, _this.control.measurer, _this.selection.intervalsInfo.subDocPosition, elements, charPropsBundle).import();
        });
        this.control.inputController.setEditableDocumentContent("");
        return true;
    };
    return InsertHtmlCommand;
}(command_base_1.CommandBase));
exports.InsertHtmlCommand = InsertHtmlCommand;
var InsertPlainTextCommand = (function (_super) {
    tslib_1.__extends(InsertPlainTextCommand, _super);
    function InsertPlainTextCommand() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    InsertPlainTextCommand.prototype.getState = function () {
        return new command_states_1.SimpleCommandState(this.isEnabled());
    };
    InsertPlainTextCommand.prototype.executeCore = function (_state, options) {
        var _this = this;
        var text = options.param;
        var result = false;
        var subDocument = this.selection.activeSubDocument;
        var position = this.selection.anchorPosition;
        var subDocumentPosition = new sub_document_1.SubDocumentPosition(subDocument, position);
        var charPropsBundle = this.control.inputPosition.charPropsBundle;
        var parPropsBundle = this.control.inputPosition.parPropsBundle;
        this.history.addTransaction(function () {
            _this.modelManipulator.range.removeInterval(_this.selection.subDocumentInterval, true, false);
            new txt_importer_1.TxtImporter().importFromString(text, subDocument.documentModel.modelOptions, function (model, _formatImagesImporter) {
                new create_range_copy_operation_1.RangeCopy(model, false).insertTo(_this.control.modelManager.modelManipulator, subDocumentPosition);
                result = true;
            }, function (_reason) {
                result = false;
            }, charPropsBundle, parPropsBundle);
        });
        return result;
    };
    return InsertPlainTextCommand;
}(command_base_1.CommandBase));
var BuiltInClipboardAction;
(function (BuiltInClipboardAction) {
    BuiltInClipboardAction[BuiltInClipboardAction["Copy"] = 0] = "Copy";
    BuiltInClipboardAction[BuiltInClipboardAction["Paste"] = 1] = "Paste";
    BuiltInClipboardAction[BuiltInClipboardAction["Cut"] = 2] = "Cut";
})(BuiltInClipboardAction = exports.BuiltInClipboardAction || (exports.BuiltInClipboardAction = {}));
